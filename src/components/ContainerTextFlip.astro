---
interface Props {
  words?: string[];
  interval?: number;
  className?: string;
  textClassName?: string;
  animationDuration?: number;
}

const {
  words = ["JEE", "NEET", "UPSC"],
  interval = 3000,
  className = "",
  textClassName = "",
  animationDuration = 700,
} = Astro.props;

const uniqueId = `container-text-flip-${Math.random().toString(36).substr(2, 9)}`;
const wordsJson = JSON.stringify(words);
---

<div
  class={`container-text-flip ${className}`}
  id={uniqueId}
  data-words={wordsJson}
  data-interval={interval}
  data-duration={animationDuration}
>
  <p class="container-text-flip-wrapper">
    <span class="container-text-flip-sizer" aria-hidden="true">
      {words.reduce((longest, word) => word.length > longest.length ? word : longest, words[0])}
    </span>
    {words.map((word, index) => (
      <span
        class={`container-text-flip-text ${index === 0 ? 'active' : ''} ${textClassName}`}
        data-index={index}
      >
        {word.split("").map((letter, letterIndex) => (
          <span class="container-text-flip-letter" data-letter-index={letterIndex}>
            {letter}
          </span>
        ))}
      </span>
    ))}
  </p>
</div>

<style>
  .container-text-flip {
    display: inline-flex;
    align-items: baseline;
    position: relative;
    background: transparent;
    color: #000;
  }

  .container-text-flip-wrapper {
    position: relative;
    display: inline-block;
    margin: 0;
    padding: 0;
    border-radius: 0;
    text-align: left;
    font-size: inherit;
    font-weight: inherit;
    line-height: inherit;
    letter-spacing: inherit;
    color: inherit;
    background: transparent;
    box-shadow: none;
    transition: width 0.35s ease-in-out;
    overflow: hidden;
    white-space: nowrap;
    min-width: auto;
  }

  @media (min-width: 768px) {
    .container-text-flip-wrapper {
      font-size: 2rem;
    }
  }

  .container-text-flip-sizer {
    visibility: hidden;
    display: inline-block;
    white-space: nowrap;
    padding: 0;
  }

  .container-text-flip-text {
    position: absolute;
    top: 0;
    left: 0;
    transform: none;
    display: inline-block;
    white-space: nowrap;
    color: inherit;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    z-index: 1;
  }

  .container-text-flip-text.active {
    opacity: 1;
    visibility: visible;
    z-index: 2;
  }

  .container-text-flip-letter {
    display: inline-block;
    opacity: 0;
    filter: blur(10px);
    transition: opacity 0.7s ease-in-out, filter 0.7s ease-in-out;
  }

  .container-text-flip-text.active .container-text-flip-letter {
    opacity: 1;
    filter: blur(0px);
  }
</style>

<script>
  import { gsap } from 'gsap';

  function initContainerTextFlip() {
    const containers = document.querySelectorAll('[id^="container-text-flip-"]');
    
    containers.forEach((container) => {
      if ((container as any)._containerTextFlipInitialized) return;
      (container as any)._containerTextFlipInitialized = true;

      const wordsData = (container as HTMLElement).dataset.words;
      const interval = parseInt((container as HTMLElement).dataset.interval || '3000', 10);
      const duration = parseInt((container as HTMLElement).dataset.duration || '700', 10);
      
      if (!wordsData) return;
      
      const words: string[] = JSON.parse(wordsData);
      const wrapper = container.querySelector('.container-text-flip-wrapper') as HTMLElement;
      const textElements = container.querySelectorAll('.container-text-flip-text');
      
      if (textElements.length === 0 || words.length === 0 || !wrapper) return;
      
      let currentIndex = 0;
      let intervalId: number | null = null;
      let currentAnimation: gsap.core.Timeline | null = null;
      
      function updateWidth() {
        const activeText = container.querySelector('.container-text-flip-text.active') as HTMLElement;
        if (activeText) {
          const textWidth = activeText.offsetWidth;
          gsap.to(wrapper, {
            width: textWidth,
            duration: duration / 1000,
            ease: 'easeInOut'
          });
        }
      }
      
      function animateLetters(textElement: HTMLElement) {
        const letters = textElement.querySelectorAll('.container-text-flip-letter');
        letters.forEach((letter, index) => {
          const letterEl = letter as HTMLElement;
          letterEl.style.transitionDelay = `${index * 0.02}s`;
        });
      }
      
      function animateTransition() {
        const currentText = textElements[currentIndex] as HTMLElement;
        const nextIndex = (currentIndex + 1) % words.length;
        const nextText = textElements[nextIndex] as HTMLElement;
        
        if (!currentText || !nextText) return;
        
        // Kill any ongoing animation
        if (currentAnimation) {
          currentAnimation.kill();
        }
        
        // Animate letters in for next word
        animateLetters(nextText);
        
        // Create timeline
        const tl = gsap.timeline({
          onComplete: () => {
            currentText.classList.remove('active');
            nextText.classList.add('active');
            currentIndex = nextIndex;
            updateWidth();
          }
        });
        
        // Animate current word out
        tl.to(currentText, {
          opacity: 0,
          filter: 'blur(10px)',
          duration: duration / 1000,
          ease: 'easeInOut'
        });
        
        // Animate next word in
        nextText.classList.add('active');
        tl.to(nextText, {
          opacity: 1,
          filter: 'blur(0px)',
          duration: duration / 1000,
          ease: 'easeInOut'
        }, '-=0.3');
        
        currentAnimation = tl;
        updateWidth();
      }
      
      // Initialize first word
      textElements.forEach((text, index) => {
        const textEl = text as HTMLElement;
        if (index === 0) {
          textEl.classList.add('active');
          textEl.style.opacity = '1';
          textEl.style.filter = 'blur(0px)';
          animateLetters(textEl);
        } else {
          textEl.classList.remove('active');
          textEl.style.opacity = '0';
          textEl.style.filter = 'blur(10px)';
        }
      });
      
      // Set initial width immediately
      const firstActiveText = textElements[0] as HTMLElement;
      if (firstActiveText) {
        const initialWidth = firstActiveText.offsetWidth;
        wrapper.style.width = `${initialWidth}px`;
      }
      
      // Update width after a short delay to ensure layout is complete
      setTimeout(updateWidth, 50);
      
      // Start animation
      intervalId = window.setInterval(animateTransition, interval) as unknown as number;
      
      // Intersection Observer
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            if (!intervalId) {
              intervalId = window.setInterval(animateTransition, interval) as unknown as number;
            }
          } else {
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = null;
            }
            if (currentAnimation) {
              currentAnimation.kill();
              currentAnimation = null;
            }
          }
        });
      }, { threshold: 0.1 });
      
      observer.observe(container);
      
      // Store cleanup
      (container as any)._containerTextFlipCleanup = () => {
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
        }
        if (currentAnimation) {
          currentAnimation.kill();
          currentAnimation = null;
        }
        observer.disconnect();
        (container as any)._containerTextFlipInitialized = false;
      };
    });
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initContainerTextFlip);
  } else {
    initContainerTextFlip();
  }
  
  // Re-initialize on Astro page transitions
  document.addEventListener('astro:page-load', () => {
    document.querySelectorAll('[id^="container-text-flip-"]').forEach((container) => {
      if ((container as any)._containerTextFlipCleanup) {
        (container as any)._containerTextFlipCleanup();
      }
    });
    setTimeout(initContainerTextFlip, 50);
  });
</script>

