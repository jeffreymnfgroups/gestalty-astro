---
interface Props {
  words: string[];
  duration?: number;
  className?: string;
}

const { words, duration = 2000, className = "" } = Astro.props;
// Generate stable ID based on words content to avoid mismatches
const wordsHash = words.join('-').replace(/[^a-z0-9-]/gi, '').substring(0, 20) || 'default';
const uniqueId = `flip-words-${wordsHash}`;
const wordsJson = JSON.stringify(words);
---

<div class={`flip-words-container ${className}`} id={uniqueId} data-words={wordsJson} data-duration={duration}>
  <span class="flip-words-wrapper">
    <span class="flip-words-sizer" aria-hidden="true">
      {words.reduce((longest, word) => word.length > longest.length ? word : longest, words[0])}
    </span>
    {words.map((word, index) => (
      <span 
        class={`flip-word ${index === 0 ? 'active' : ''}`}
        data-index={index}
      >
        {word}
      </span>
    ))}
  </span>
  <span class="flip-words-underline"></span>
</div>

<style>
  .flip-words-container {
    display: inline-block;
    position: relative;
  }

  .flip-words-wrapper {
    display: inline-block;
    position: relative;
    min-height: 1.2em;
  }

  .flip-words-sizer {
    visibility: hidden;
    display: inline-block;
    white-space: nowrap;
  }

  .flip-word {
    display: inline-block;
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    white-space: nowrap;
    transform: translateY(20px);
    transition: opacity 0.5s ease-out,
                transform 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                visibility 0s 0.5s;
    will-change: transform, opacity;
    z-index: 1;
  }

  .flip-word.active {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    transform: translateY(0);
    transition: opacity 0.5s ease-in,
                transform 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                visibility 0s;
    z-index: 2;
  }

  .flip-words-underline {
    position: absolute;
    bottom: -4px;
    left: 0;
    height: 3px;
    background: linear-gradient(90deg, #fbc10d 0%, #ffd700 50%, #fbc10d 100%);
    background-size: 200% 100%;
    border-radius: 2px;
    width: 0;
    transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    animation: shimmer 3s ease-in-out infinite;
    z-index: 3;
  }

  @keyframes shimmer {
    0%, 100% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
  }
</style>

<script>
  function initFlipWords() {
    const containers = document.querySelectorAll('[id^="flip-words-"]');
    
    containers.forEach((container) => {
      const wordsData = (container as HTMLElement).dataset.words;
      const duration = parseInt((container as HTMLElement).dataset.duration || '2000', 10);
      
      if (!wordsData) return;
      
      const words: string[] = JSON.parse(wordsData);
      const wordElements = container.querySelectorAll('.flip-word');
      const underline = container.querySelector('.flip-words-underline') as HTMLElement;
      
      if (wordElements.length === 0 || words.length === 0) return;
      
      let currentIndex = 0;
      let intervalId: number | null = null;
      
      // Initialize first word
      wordElements.forEach((word, index) => {
        (word as HTMLElement).classList.remove('active');
        if (index === 0) {
          (word as HTMLElement).classList.add('active');
          container.classList.add('active');
        }
      });
      
      function updateUnderline() {
        if (!underline) return;
        const activeWord = container.querySelector('.flip-word.active') as HTMLElement;
        if (activeWord && activeWord.offsetWidth > 0) {
          underline.style.width = activeWord.offsetWidth + 'px';
        }
      }
      
      function animate() {
        const currentWord = wordElements[currentIndex] as HTMLElement;
        const nextIndex = (currentIndex + 1) % words.length;
        const nextWord = wordElements[nextIndex] as HTMLElement;
        
        if (!currentWord || !nextWord) return;
        
        // Remove active from current
        currentWord.classList.remove('active');
        container.classList.remove('active');
        
        // After fade out, switch to next word
        setTimeout(() => {
          nextWord.classList.add('active');
          container.classList.add('active');
          currentIndex = nextIndex;
          
          // Update underline width to match new word
          updateUnderline();
        }, 500);
      }
      
      // Start animation
      intervalId = window.setInterval(animate, duration) as unknown as number;
      
      // Initialize underline width
      updateUnderline();
      setTimeout(updateUnderline, 200);
      
      // Intersection Observer to pause when not visible
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            if (!intervalId) {
              intervalId = window.setInterval(animate, duration) as unknown as number;
            }
          } else {
            if (intervalId) {
              clearInterval(intervalId);
              intervalId = null;
            }
          }
        });
      }, { threshold: 0.1 });
      
      observer.observe(container);
      
      // Store cleanup function
      (container as any)._flipCleanup = () => {
        if (intervalId) {
          clearInterval(intervalId);
          intervalId = null;
        }
        observer.disconnect();
      };
    });
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFlipWords);
  } else {
    initFlipWords();
  }
  
  // Re-initialize on Astro page transitions
  document.addEventListener('astro:page-load', () => {
    // Cleanup existing instances
    document.querySelectorAll('[id^="flip-words-"]').forEach((container) => {
      if ((container as any)._flipCleanup) {
        (container as any)._flipCleanup();
      }
    });
    // Reinitialize
    setTimeout(initFlipWords, 50);
  });
</script>
